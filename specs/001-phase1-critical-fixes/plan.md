# Implementation Plan: Phase 1 Critical Fixes

**Branch**: `001-phase1-critical-fixes` | **Date**: 2025-12-14 | **Spec**: [Phase 1 Specification](spec.md)

**Input**: Feature specification from `/specs/001-phase1-critical-fixes/spec.md`

**Note**: This implementation plan details the technical architecture, design decisions, and phased approach for Phase 1 critical fixes (testing infrastructure, content translation, bug fixes, README rewrite).

---

## Summary

Phase 1 delivers four critical features that remove automatic rejection triggers from hiring team evaluation. The implementation prioritizes rapid impact: setting up automated test infrastructure first, then fixing all outstanding bugs and translation issues, then documenting the work professionally.

**Core Technical Approach**:
1. **Test Infrastructure First**: Install Vitest + Testing Library, establish patterns for component and utility testing
2. **Quality Gates**: Configure ESLint + TypeScript strict mode to prevent new bugs
3. **Parallel Work**: While tests are being written, translate content and fix bugs (no dependencies)
4. **Documentation Last**: README and comments written after code is production-ready

---

## Technical Context

**Language/Version**: TypeScript 5.x, React 18.x, Next.js 14.x

**Primary Dependencies**:
- Testing: Vitest 1.0+, @testing-library/react 14.0+, happy-dom 12.0+
- Quality: ESLint (existing), TypeScript strict mode (enable)
- Content: No new dependencies (translation is text replacement)

**Storage**: N/A (no database changes)

**Testing**: Vitest as primary test runner with React Testing Library for components, standard assertions for utilities

**Target Platform**: Web (Next.js production deployment on Vercel)

**Project Type**: Single monolith web application (portfolio site)

**Performance Goals**: Maintain 90+ Lighthouse Performance score, < 100KB initial JS, < 1.5s First Contentful Paint

**Constraints**:
- Must not break existing functionality
- Must not introduce breaking changes to component APIs
- Coverage threshold enforced in CI (minimum 25%)
- No external API changes required

**Scale/Scope**:
- ~35 UI components to potentially test (prioritize high-value ones)
- ~10 utility/library functions to test
- ~1 page-level integration test
- 2-3 blog posts to verify translation
- 1 README complete rewrite

---

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

| Principle | Requirement | Phase 1 Implementation |
|-----------|-------------|----------------------|
| **I. Production-Ready Code** | Zero known bugs, type-safe, error handling, 30%+ tests, verified performance | ✅ All required by acceptance criteria |
| **II. Quality-First Workflow** | Tests first, types first, docs alongside | ✅ Vitest setup enables TDD; tests written before implementation |
| **III. Language Consistency** | 100% English, professional, no template text | ✅ Content translation user story; README rewrite story |
| **IV. Evidence-Based Claims** | All claims backed by proof | ✅ Lighthouse audit results documented in README |
| **V. CI/CD Automation** | Linting/testing automated, blocks merge on failure | ✅ ESLint + test suite configured; Phase 2 adds GitHub Actions |

**Constitution Alignment**: Phase 1 implementation directly addresses Principles I-III. Principles IV and V are partially addressed (evidence documented, automation foundation set).

---

## Project Structure

### Documentation (this feature)

```
specs/001-phase1-critical-fixes/
├── spec.md              # Feature specification with user stories
├── plan.md              # This file (implementation plan)
├── research.md          # Technical research (optional, included if needed)
├── data-model.md        # N/A (no data models for this feature)
├── quickstart.md        # Getting started guide for Phase 1
├── checklists/
│   └── requirements.md  # Specification quality validation
└── tasks.md             # Generated by /speckit.tasks command
```

### Source Code (repository root)

```
# Test Infrastructure
__tests__/
├── setup.ts                              # Global test setup, imports
├── components/
│   ├── ui/
│   │   ├── button.test.tsx              # Button component tests
│   │   ├── card.test.tsx                # Card component tests
│   │   └── [other-ui-tests].test.tsx    # Additional UI component tests
│   └── github-repositories.test.tsx      # Complex component test
└── lib/
    ├── blog.test.ts                     # Blog utility tests
    └── utils.test.ts                    # Utility function tests

# Configuration
vitest.config.ts                         # Test runner configuration
.eslintrc.json                           # ESLint rules (updated)
tsconfig.json                            # TypeScript strict mode

# Content (modified)
lib/resume.tsx                           # Translations (UI strings, descriptions)
components/github-repositories.tsx       # Translations (UI strings)
content/*.mdx                            # Blog translations (if any)
app/page.tsx                             # Homepage translation
README.md                                # Complete rewrite
```

**Structure Decision**: Single monolith architecture maintained. Tests mirror source structure (`components/` → `__tests__/components/`, `lib/` → `__tests__/lib/`). This allows developers to quickly locate tests alongside source files.

---

## Phase Breakdown

### Phase 0: Foundation Setup (Day 1 - 2 hours)

**Objective**: Install dependencies, create test infrastructure, establish patterns

**Tasks**:
1. Install Vitest, Testing Library, happy-dom, and dev dependencies
2. Create `vitest.config.ts` with:
   - Path aliases matching `tsconfig.json` (`@/*` → root)
   - Happy-dom environment (lightweight)
   - Coverage configuration (threshold: 25% minimum, report: `coverage/`)
3. Create `__tests__/setup.ts` with:
   - Vitest imports
   - Testing Library extended matchers
   - Global setup (e.g., mocking next/router if needed)
4. Add npm scripts:
   - `"test": "vitest"`
   - `"test:watch": "vitest --watch"`
   - `"test:ui": "vitest --ui"`
   - `"test:coverage": "vitest --coverage"`
5. Create `.gitignore` entry for `coverage/` directory
6. Verify basic test runs: `npm test` succeeds with no tests

**Deliverable**: Test infrastructure working; developers can write and run tests

---

### Phase 1A: Bug Fixes (Day 1 - 1 hour, parallel with Phase 0)

**Objective**: Identify and fix all production bugs before writing tests

**Tasks**:
1. Audit all Next.js Link components for:
   - Duplicate href attributes (next/link with nested `<a href>`)
   - Missing `rel="noopener noreferrer"` on external links
   - Improper ARIA labels on interactive elements
2. Fix `components/github-repositories.tsx`:
   - Remove redundant `<a>` tags inside Link components
   - Add proper rel attributes
   - Add aria-labels where needed
3. Audit remaining components for similar patterns
4. Run `pnpm lint` and fix all reported errors
5. Run `pnpm build` and verify zero TypeScript errors
6. Manual testing: Click all links, verify navigation works

**Deliverable**: Zero production bugs; ESLint + TypeScript both pass

---

### Phase 1B: Content Translation (Day 1-2 - 3 hours, parallel with Phases 0/1A)

**Objective**: Audit codebase for Slovak content, translate to professional English

**Tasks**:
1. Audit codebase for Slovak strings:
   - Grep for known Slovak patterns in `*.tsx`, `*.ts`, `*.mdx` files
   - Manual review of `lib/resume.tsx` (repository descriptions)
   - Manual review of `components/github-repositories.tsx` (UI labels)
   - Manual review of blog post metadata and homepage content
2. Translate identified content:
   - Repository descriptions (if any in Slovak)
   - UI labels and button text
   - Data descriptions in resume
   - Blog titles/summaries (if any in Slovak)
3. Grammar check all English content:
   - Use Grammarly or similar
   - Ensure consistent terminology throughout
   - Professional business English (not conversational)
4. Manual review of live site:
   - Ensure zero visible Slovak text
   - Verify translations read naturally
   - Check formatting/spacing not affected

**Deliverable**: Zero Slovak text in production; all English is professional and grammatically correct

---

### Phase 1C: Test Writing (Days 1-4 - 6-8 hours)

**Objective**: Write tests that verify code works as intended

**Strategy**: Write tests FIRST, then implementations only if code changes needed

**Minimal Testing Approach** (avoid over-testing):
- Focus on high-value components and utilities
- Test behavior, not implementation
- Test critical user journeys, not every code path

**Test Suite Structure**:

**Unit Tests (4-6 hours)** - Utilities & helpers
- `__tests__/lib/utils.test.ts`:
  - Test `cn()` utility with multiple Tailwind classes
  - Test any date formatting or type guard functions
  - Aim for 80%+ coverage of utilities
- `__tests__/lib/blog.test.ts`:
  - Test blog post retrieval functions
  - Test type guards (`isFullArticle()` if used)
  - Test any data transformations

**Component Tests (2-3 hours)** - UI Components
- `__tests__/components/ui/button.test.tsx`:
  - Test button renders with correct props
  - Test click handlers work
  - Test disabled state
- `__tests__/components/ui/card.test.tsx`:
  - Test card renders children
  - Test props propagate correctly
- `__tests__/components/github-repositories.test.tsx`:
  - Test repositories render
  - Test links work
  - Test hover states (if interactive)
- Aim for 60%+ coverage of components

**Deliverable**: 30%+ overall coverage; all tests passing; coverage report generated

---

### Phase 1D: README Rewrite (Days 4-5 - 2 hours)

**Objective**: Rewrite README following professional open-source standards

**Current State Problems**:
- Reads like personal bio, not technical project
- No live demo link
- No feature highlights
- No getting started guide
- No performance evidence

**New README Structure**:
1. **Header** (100px max scroll):
   - Project title: "Marian Holly Portfolio"
   - Short description: "A modern, production-grade portfolio site showcasing full-stack web development skills"
   - Live demo link (prominent)
   - Build status badge (when CI implemented)

2. **Key Features** (no more than 6 bullets):
   - Fast, performant site (90+ Lighthouse scores)
   - Full-stack capabilities (Next.js, React, TypeScript)
   - Responsive design with dark mode
   - Blog with syntax highlighting
   - Optimized for hiring team evaluation

3. **Tech Stack** (with brief rationale):
   - Frontend: Next.js 14, React 18, TypeScript (why: modern, type-safe, performant)
   - Styling: Tailwind CSS, shadcn/ui (why: utility-first, accessible components)
   - Content: MDX, gray-matter (why: powerful content pipeline with syntax highlighting)
   - Animation: Framer Motion (why: smooth, professional animations)
   - Deployment: Vercel (why: zero-config, automatic deploys)

4. **Performance** (with evidence):
   - Lighthouse scores (screenshots or percentages):
     - Performance: 95+
     - Accessibility: 98+
     - Best Practices: 100
     - SEO: 100
   - Core Web Vitals (LCP, FID, CLS)
   - Bundle size analysis

5. **Getting Started**:
   - Clone repo
   - Install: `pnpm install`
   - Dev: `pnpm dev`
   - Build: `pnpm build`
   - Test: `pnpm test`

6. **Project Structure** (brief overview):
   - `app/` - Next.js App Router pages
   - `components/` - React components (35+ UI components)
   - `lib/` - Utilities and blog processing
   - `content/` - MDX blog posts
   - `__tests__/` - Test files

7. **Testing**:
   - Vitest for unit and component tests
   - 30%+ code coverage
   - Run: `pnpm test`

8. **Deployment**:
   - Automated to Vercel on main branch push
   - Preview deployments on every PR
   - Live at: marianholly.vercel.app

9. **Security**:
   - Environment variables in `.env.local` (not committed)
   - Input sanitization with rehype-sanitize
   - Content Security Policy enabled

**Deliverable**: Professional README without personal content; hiring teams see technical credibility

---

## Testing Strategy

### Test-Driven Development Approach

Tests MUST be written first, BEFORE implementation:

```
1. Write failing test → RED
2. Implement minimal code to pass test → GREEN
3. Refactor for clarity → REFACTOR
4. Move to next test → Repeat
```

### Coverage Targets

| Category | Target | Rationale |
|----------|--------|-----------|
| **Utilities** | 80%+ | Pure functions, high value, easy to test |
| **Components** | 60%+ | Rendering and props; skip trivial tests |
| **Integration** | 30%+ | Page-level tests; focus on critical flows |
| **Overall** | 30%+ | Minimum threshold for Phase 1 |

### What NOT to Test

- Visual appearance (screenshot tests add complexity)
- External APIs (mock them)
- Implementation details (test behavior, not code paths)
- Next.js internals (trust the framework)
- Trivial getters/setters

### Test Quality Principles

- **One assertion per test** (when possible) - easier to debug
- **Clear test names** - test name describes what it tests
- **Arrange-Act-Assert** - setup, execute, verify pattern
- **Minimal mocks** - use real implementations when safe

---

## Code Quality Gates

### ESLint Configuration

Extend existing `.eslintrc.json` with:
- `unicorn/prefer-node-protocol` - Enforce `node:` protocol
- `jsx-a11y/click-events-have-key-events` - Ensure interactive elements accessible
- `jsx-a11y/alt-text` - Require alt text on images
- `no-console` - Warn on console.log (fail in CI)

### TypeScript Strict Mode

Enable in `tsconfig.json`:
```json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "noImplicitThis": true
  }
}
```

### Pre-Commit Verification

Manual checks (pre-commit hooks added in Phase 2):
1. `pnpm lint` - ESLint passes
2. `pnpm test` - Tests pass
3. `pnpm build` - TypeScript compiles
4. Manual: No console errors in DevTools
5. Manual: Links work on live site

---

## Complexity Tracking

No constitution violations identified. Phase 1 is straightforward implementation of documented requirements.

---

## Dependencies & Blockers

### Internal Dependencies
- Phase 0 (Test Setup) → Phase 1C (Test Writing)
- Phase 1A (Bug Fixes) → Independent (can run parallel)
- Phase 1B (Translation) → Independent (can run parallel)
- Phase 1C (Testing) → Phase 1D (README mentioning tests)
- All phases → Phase 1D (README rewrite can reference all changes)

### External Dependencies
- None (Phase 1 is self-contained)

### Blockers for Phase 2
- Phase 1 MUST complete before Phase 2 (CI/CD relies on passing tests)

---

## Success Criteria from Spec

**Testing Infrastructure**
- ✅ `pnpm test` runs successfully
- ✅ Coverage report generated (30%+)
- ✅ 5+ component tests passing
- ✅ 3+ utility tests passing
- ✅ All tests pass in CI

**Content Translation**
- ✅ Zero Slovak text on live site
- ✅ All navigation labels in English
- ✅ All descriptions in English
- ✅ Grammar checked and professional

**Bug Fixes**
- ✅ No duplicate href attributes
- ✅ External links have proper rel attributes
- ✅ ESLint passes
- ✅ Zero TypeScript errors
- ✅ Zero console errors on production site

**README**
- ✅ No personal bio content
- ✅ Live demo link prominent
- ✅ Screenshots included
- ✅ Tech stack documented
- ✅ Getting started works
- ✅ Performance metrics included

---

## Time Breakdown

| Phase | Hours | Notes |
|-------|-------|-------|
| Phase 0 - Test Setup | 2 | Vitest config, test structure, npm scripts |
| Phase 1A - Bug Fixes | 1 | Audit + fix Link components, ESLint issues |
| Phase 1B - Translation | 3 | Audit files, translate content, grammar check |
| Phase 1C - Test Writing | 7 | Unit tests (4h) + Component tests (3h) |
| Phase 1D - README | 2 | Rewrite with professional structure |
| **Total** | **15 hours** | Within DEV_PLAN estimate of 16-20 hours |

---

## Rollout Strategy

**Approach**: Complete all phases, then single large merge to main (or multiple PR merges if preferred)

**Deployment Gate**: Only merge to main after:
- ✅ All tests passing
- ✅ ESLint: zero errors
- ✅ Build: successful
- ✅ Manual testing: completed
- ✅ No console errors on production site

**Post-Deployment**: Verify live site loads correctly and all features work

---

## Risk Mitigation

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|-----------|
| Tests difficult to write | Medium | Medium | Start with utilities (easier), progress to components |
| Coverage lower than 30% | Low | Medium | Focus on high-value functions/components first |
| Time estimates optimistic | Medium | Medium | Track actual time, adjust Phase 2 if needed |
| Breaking changes during refactor | Low | High | Make small incremental changes, test frequently |

---

## Notes

This plan keeps implementation focused and lean. The goal is rapid impact on hiring outcomes, not comprehensive test coverage. Phase 1 tests establish patterns that Phase 2 and 3 will expand upon.

**Next Steps**:
1. Execute Phase 0: Test infrastructure setup
2. Execute Phase 1A-1D in parallel (A, B independent; C after 0; D after all)
3. Generate task list via `/speckit.tasks`
4. Begin Task 1.1 (Test Setup)
